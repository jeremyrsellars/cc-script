---
title: "Clinical Connect Performance"
author: "Jeremy R. Sellars - Softek Solutions"
date: "November 22, 2017"
output:
  word_document: default
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("chron")
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("DBI")
#install.packages("dplyr")
#install.packages("backports", type="source")
#install.packages("rmarkdown")

#install.packages("devtools")
#require(devtools)
#install_version("backports", version = "1.1.0")

library(chron)
library(ggplot2)
library(scales)
library(knitr)
library(dplyr)
```

# Executive Summary

This report contains information gathered by Softek, using web-automation tooling to drive the Clinical Connect UI, searching for a patient, opening the patient, and waiting for the labs to be available.

The data is from part of Friday November 18th, through part of Wednesday November 22nd, 2017.

## Findings

* The ClinicalConnect application seems to be subject to timeouts, during both peak and off-peak hours.
* The problem may be related to the amount of data being retrieved.  E.g. Labs for All Regional Encounters for the past 180 days may retrieve more data than just the current encounter for the past 90 days.
* The ClinicalConnect application success/failure behavior seemed to drasticly improve starting Monday November 20th.

\pagebreak

# Response time-to-glass visualization

Here are the timing results for 2 operations, starting on the fourth day of the engagement.  For details, see the Test Methods section.

1. Search - Type the patient PIN into the header search box and press enter.
2. Open - Click the patient's row in the grid, click through not-my-patient override, and wait for labs.

```{r plots, echo=F}

parseExcelDate <- function (s) {
  dtparts = t(as.data.frame(strsplit(as.character(s),' ')))
  row.names(dtparts) = NULL
  as.POSIXlt(
    chron(dates=dtparts[,1],times=dtparts[,2],
          format=c('m/d/y','h:m:s')), tz="UTC")
}

open_006 <- function(csv_path) {
  names_006 <- c("StartSearch","Search","StartOpen","Open","EndOpen", "screenshot", "Status", "Blank1", "Blank")
  dt <- read.csv(csv_path, header = F, stringsAsFactors = F)
  colnames(dt) <- names_006
  dt$Search <- dt$Search/1000 # ms -> s
  dt$Open <- dt$Open/1000 # ms -> s
  dt$StartSearch <- parseExcelDate(dt$StartSearch)
  dt$StartOpen <- parseExcelDate(dt$StartOpen)
  dt$EndOpen <- parseExcelDate(dt$EndOpen)
  dt$Status <- gsub(" ?[-.].*", "", dt$Status, perl=T)
  dt$Status <- ifelse(is.na(dt$Status), "", dt$Status)
  dt$Status <- ifelse(dt$Status == "", "Opened Successfully", dt$Status)

  dt <- dt[,c("StartSearch","Search","StartOpen","Open","EndOpen", "Status")]
}

StatusColors <- c(
      "Opened Successfully"="#0072B2",
      "Search"="#999999",
      "Request timed out: LTVH"="#A69F00",
      "Data failed to retrieve from LTVH"="#E69F00",
      "Error 007: An unknown error has occurred"="#F0E442",
      "#0072B2",
      "#D55E00",
      "#CC79A7")

plot_006 <- function(dt, patient) {
  timeout=600
  show_timeout <- T # max(dt[,c("Search","Open")]) > 600
  cutoff <- data.frame( x = c(min(dt$StartSearch), max(dt$StartSearch)), y = timeout, timeout = factor(timeout))
  ggp <-
    ggplot(dt) +
    geom_point(aes(StartSearch, Search, colour="Search")) +
    geom_point(aes(StartOpen, Open, colour=Status))
  if(show_timeout) ggp <- ggp +
    geom_line(aes( x, y, linetype = timeout), cutoff)
  ggp <- ggp + 
    ylab("Seconds") +
    ggtitle("Response Times", patient) +
    scale_x_datetime() +
    scale_y_continuous(breaks=seq(0, timeout, 60))
    scale_color_manual(values=StatusColors)
  ggp
}
  
samples_plot_006 <- function(dt, patient) {
  dt <- dt[,c("StartSearch","Status")]
  dt$StartSearch <- gsub(" .*", "", as.POSIXct(dt$StartSearch))
  
  ggplot(dt %>% count(StartSearch, Status) %>%    # Group by date and message, then count number in each group
           mutate(pct=n/sum(n),               # Calculate percent within each day
                  ypos = cumsum(n) - 0.5*n),  # Calculate label positions
         aes(StartSearch, n, fill=Status)) +
    geom_bar(stat="identity") +
    geom_text(aes(label=ifelse(pct*100 > 2, paste0(sprintf("%1.1f", pct*100),"%"), "")),
              color="#FFFFFF",
              position=position_stack(vjust=0.5)) +
    scale_fill_manual(values=StatusColors) +
    ylab("# of tests") +
    ggtitle("Test results by day", patient)
}

hist_006 <- function(dt, patient) {
  timeout=600
  show_timeout <- max(dt[,c("Search","Open")]) > 600
  cutoff <- data.frame( x = c(min(dt$StartSearch), max(dt$StartSearch)), y = timeout, timeout = factor(timeout))
  sTemp <- as.data.frame(dt$Search / 60)
  colnames(sTemp) <- "Minutes"
  sTemp$Operation = "Search"
  oTemp <- as.data.frame(dt$Open / 60)
  colnames(oTemp) <- "Minutes"
  oTemp$Operation = "Open"
  
  opTimes <- as.data.frame(rbind(sTemp, oTemp))
  ggp <-
    ggplot(opTimes) +
    geom_histogram(alpha = 0.5, binwidth=0.5, aes(Minutes, fill=Operation, color=Operation), position = 'identity')
  
  ggp <- ggp + 
    ggtitle(paste(patient, "Response - Time Histogram"))
  ggp
}
#hist_006(rp1_d1, "Hi")
#dt <- tp1_d1
#patient <-"hi"
open_hist_006 <- function(dt, patient) {
  dt <- dt[which(dt$Status == "Opened Successfully"),c("StartOpen", "Open")]
  dt <- dt[which(dt$Open <= 100),]
  dt$StartOpen <- as.factor(gsub(" .*", "", as.POSIXct(dt$StartOpen)))
  maxSeconds <- 60
  colorStart <- 100
  colorDelta <- -120
  binwidth = 5 # seconds

  suppressWarnings(
    ggplot(dt, aes(Open, fill=cut(Open, 60))) +
      geom_histogram(binwidth=binwidth, boundary=0, show.legend = F) +
      xlab("seconds") +
      scale_x_continuous(limits=c(0, maxSeconds),
                         breaks=seq(0, maxSeconds, binwidth * 2),
                         labels=function(s)paste0(s, "s"))+
      scale_fill_discrete(h = c(100, 100 + -120 * max(dt$Open) / maxSeconds)) +
      ylab("# of tests") +
      facet_wrap(~StartOpen) +
      ggtitle("How often is it fast vs slow?",
              paste("OpenPatient response times by day for", patient, "cut into", binwidth, "second chunks")))
}
#open_hist_006(section_dt, section_title)

summarize <- function (dt){
  total = nrow(dt)
  timeouts = nrow(dt[which(dt$Open >= 600),])
  successes = total - timeouts
  smry <- as.data.frame(list(
    count=nrow(dt),
    OpenSuccess=successes,
    OpenTimeouts=timeouts,
    OpenTimeoutPercent=paste0(floor(100*timeouts/total), "%")))
  colnames(smry) <- c("Sample Count (Open Patient w/ Labs)", "Success", "Timeout", "Timeout %")
  smry
}
```

Plots and statistical analysis are presented for both a real patient and a test patient for comparison.

\pagebreak

## Real Patient

This shows the Search and Open timing for a real patient.  The ClinicalConnect UI seems to timeout when a request takes longer than 10 minutes (600s), presumably because it is waiting for data from the server.

```{r echo=F, fig.width=10}

#rp1_d1 <- open_006("..\\data\\AllRegionalEncounters_180d_0.0.6\\rp1.csv")
rp1_d1 <- rbind(
  open_006("..\\data\\AllRegionalEncounters_180d_0.0.6\\rp1.csv"),
  open_006("..\\data\\AllRegionalEncounters_180d_0.0.6\\part2\\rp1.csv"))
rp1_d1 <- rp1_d1[which(rp1_d1$Open < 750),] # Remove probable outlier
section_dt <- rp1_d1
section_title <- "Real Patient"

section_dt$Status <- as.factor(section_dt$Status)
section_dt <- section_dt[which(section_dt$Search < 30),] # Remove probable outlier/automation mistake
kable(summarize(section_dt))
samples_plot_006(section_dt, section_title)
plot_006(section_dt, section_title)
#hist_006(section_dt, section_title)
open_hist_006(section_dt, section_title)
kable(summary(section_dt[,c("StartSearch","Search","Open")]))
#kable(section_dt[,c("StartSearch","Search","Open")])

```

\pagebreak

## Test Patient

```{r echo=F, fig.width=10}

#tp1_d1 <- open_006("..\\data\\AllRegionalEncounters_180d_0.0.6\\tp1.csv")
tp1_d1 <- rbind(
  open_006("..\\data\\AllRegionalEncounters_180d_0.0.6\\tp1.csv"),
  open_006("..\\data\\AllRegionalEncounters_180d_0.0.6\\part2\\tp1.csv"))
section_dt <- tp1_d1
section_title <- "Test Patient"

section_dt$Status <- as.factor(section_dt$Status)
section_dt <- section_dt[which(section_dt$Search < 30),] # Remove probable outlier/automation mistake
kable(summarize(section_dt))
samples_plot_006(section_dt, section_title)
plot_006(section_dt, section_title)
#hist_006(section_dt, section_title)
open_hist_006(section_dt, section_title)
kable(summary(section_dt[,c("StartSearch","Search","Open")]))
#kable(section_dt[,c("StartSearch","Search","Open")])

```

----------

\pagebreak

# Appendix A - Test Method

The ClinicalConnect web application was automated through Chrome, running on the Panther server in one of LHSC's data centers.

1. Login.
  * ![Login](..\\data\\AllRegionalEncounters_180d\\tp.0.login.11-17-2017 14-56-05.png)
2. Search for a patient by PIN.
  * ![Search](..\\data\\AllRegionalEncounters_180d\\tp.1.patients.11-17-2017 14-56-05.png)
3. Open patient.  Click through the not-my-patient override screen.
  * (Not shown)
4. Showing Labs.
  * ![Labs](..\\data\\AllRegionalEncounters_180d\\tp.3.labs.11-17-2017 14-56-05.png)

The labs were set through settings to 180 days of All Regional Encounters, as shown here:

![Settings](..\\data\\AllRegionalEncounters_180d\\AllRegionalEncounters_180d.png)
